# 第12章 内存管理单元（MMU）

## 12.1 翻译后备缓冲区（TLB）

翻译后备缓冲区（TLB）是MMU中最近访问的页翻译的缓存。对于处理器执行的每次内存访问，MMU会检查翻译是否缓存在TLB中。如果请求的地址翻译在TLB中命中，地址翻译会立即可用。

每个TLB条目通常不仅包含物理地址和虚拟地址，还包含诸如内存类型、缓存策略、访问权限、地址空间ID（ASID）和虚拟机ID（VMID）等属性。如果TLB不包含处理器发出的虚拟地址的有效翻译（称为TLB未命中），则会执行外部翻译表遍历或查找。MMU中的专用硬件使其能够读取内存中的翻译表。如果翻译表遍历未导致页错误，则新加载的翻译可以缓存在TLB中以供可能的重用。TLB的确切结构在ARM处理器的不同实现中有所不同。

如果操作系统修改了可能已缓存在TLB中的翻译条目，则操作系统有责任使这些过时的TLB条目无效。

在执行A64代码时，有一个TLBI指令，即TLB无效指令。

```
TLBI<type><level>{IS}{,<Xt>}
```

以下列表给出了一些常见的类型字段选择。完整列表见第12-5页的表12-1。

- **ALL**：所有TLB条目。
- **VMALL**：所有TLB条目。这是当前客户操作系统的第1阶段。
- **VMALLS12**：所有TLB条目。这是当前客户操作系统的第1和第2阶段。
- **ASID**：匹配Xt中ASID的条目。
- **VA**：Xt中指定的虚拟地址和ASID的条目。
- **VAA**：Xt中指定的虚拟地址的条目，带有任何ASID。

每个异常级别（即EL3、EL2或EL1）都有自己的虚拟地址空间，操作适用于该空间。IS字段指定这仅适用于内部可共享条目。

**注意**：有关ASID的信息，请参见第12-27页的上下文切换；有关共享性概念的更多信息，请参见第12-18页的翻译表配置。

`<level>`字段简单地指定操作应适用的异常级别虚拟地址空间（可以是3、2或1）。

IS字段指定这仅适用于内部可共享条目。

**表12-1 TLB配置指令**

| TLB无效 | 变体 | 描述 |
| --- | --- | --- |
| TLBI | ALLEn | TLB无效，ELn。 |
| TLBI | ALLEnIS | TLB无效，ELn，内部可共享 |
| TLBI | ASIDE1 | TLB无效，按ASID，EL1。 |
| TLBI | ASIDE1IS | TLB无效，按ASID，EL1，内部可共享。 |
| TLBI | IPAS2E1 | TLB无效，按IPA，第2阶段，EL1。 |
| TLBI | IPAS2E1IS | TLB无效，按IPA，第2阶段，EL1，内部可共享。 |
| TLBI | IPAS2LE1IS | TLB无效，按IPA，第2阶段，最后一级，EL1，内部可共享。 |
| TLBI | VAAE1 | TLB无效，按VA，所有ASID，EL1 |
| TLBI | VAAE1IS | TLB无效，按VA，所有ASID，EL1，内部可共享。 |
| TLBI | VAALE1IS | TLB无效，最后一级，按VA，所有ASID，EL1，内部可共享。 |
| TLBI | VAEn | TLB无效，按VA，ELn |
| TLBI | VAEnIS | TLB无效，按VA，ELn，内部可共享。 |
| TLBI | VALEn | TLB无效，按VA，最后一级，ELn |
| TLBI | VALEnIS | TLB无效，按VA，最后一级，ELn，内部可共享。 |
| TLBI | VMALLE1 | TLB无效，按VMID，所有第1阶段，EL1。 |
| TLBI | VMALLE1IS | TLB无效，按VMID，EL1，内部可共享。 |
| TLBI | VMALLS12E1 | TLB无效，按VMID，所有第1和第2阶段，EL1 |
| TLBI | VMALLS12E1IS | TLB无效，按VMID，所有第1和第2阶段，EL1，内部可共享。 |

以下代码示例显示了写入由内部可共享内存支持的翻译表的序列：

```assembly
<< Writes to Translation Tables>>
DSB ISHST // 确保写入已完成
TLBI ALLE1 // 使所有TLB条目无效
DSB ISH // 确保TLB无效完成
ISB // 同步上下文并确保没有指令使用旧翻译
```

有关示例中显示的DSB和ISB屏障指令的更多信息，请参见第13-6页的屏障。

对于单个条目的更改，例如使用以下指令：

```assembly
TLBI VAE1，X0
```

该指令使与寄存器X0中指定的地址相关联的条目无效。

TLB可以容纳固定数量的条目。通过最小化由翻译表遍历引起的外部内存访问次数并获得高TLB命中率，可以实现最佳性能。ARMv8-A架构提供了一个称为连续块条目的功能，以有效利用TLB空间。翻译表块条目每个都包含一个连续位。当设置时，该位向TLB发出信号，表示它可以缓存一个覆盖多个块翻译的单个条目。查找可以索引到由连续块覆盖的地址范围中的任何位置。因此，TLB可以缓存一个条目的定义地址范围，从而可以在TLB中存储比通常可能更大的虚拟地址范围。

要使用连续位，连续块必须相邻，即它们必须对应于连续的虚拟地址范围。它们必须从对齐的边界开始，具有一致的属性，并指向相同翻译级别的连续输出地址范围。所需的对齐是，对于4KB粒度，VA[20:16]或对于64KB粒度，VA[28:21]对于所有地址都是相同的。需要以下数量的连续块：

- $16\times 4$ KB相邻块，给出4KB粒度的64KB条目。
- $32\times 32 MB$相邻块，给出L2描述符的1GB条目，$128\times 16 KB$给出L3描述符的2MB条目，当使用16KB粒度时。
- $32\times 64 Kb$相邻块，给出$64 KB$粒度的2MB条目。

如果这些条件未满足，则会发生编程错误，可能导致TLB中止或损坏的查找。此类错误的可能示例包括：

- 一个或多个表条目未设置连续位。
- 其中一个条目的输出指向对齐范围之外。

在ARMv8架构中，错误使用不允许在EL0和EL1有效地址空间之外进行权限检查，或错误地提供对EL3空间的访问。

## 12.2 内核和应用程序虚拟地址空间的分离

操作系统通常有许多应用程序或任务同时运行。每个应用程序或任务都有自己唯一的翻译表，内核在从一个任务切换到另一个任务时从一个翻译表切换到另一个翻译表。然而，内存系统的许多部分仅由内核使用，并且具有固定的虚拟到物理地址映射，其中翻译表条目很少更改。ARMv8架构提供了许多功能来有效处理这一需求。

翻译表基地址在翻译表基寄存器（TTBR0_EL1）和（TTBR1_EL1）中指定。当虚拟地址的高位全部为0时，选择由TTBR0指向的翻译表。当虚拟地址的高位全部设置为1时，选择TTBR1。您可以启用虚拟地址标记以从检查中排除前八位。

处理器指令获取或数据访问的虚拟地址为64位。然而，您必须将上述两个区域映射到单个48位物理地址内存映射中。

EL2和EL3有一个TTBR0，但没有TTBR1。这意味着：

- 如果EL2使用AArch64，它只能使用0x0到0x0000FFFF_FFFFFFFF范围内的虚拟地址。
- 如果EL3使用AArch64，它只能使用0x0到0x0000FFFF_FFFFFFFF范围内的虚拟地址。

图12-4显示了如何将内核空间映射到内存的最高有效区域，并将与每个应用程序相关联的虚拟地址空间映射到内存的最低有效区域。然而，这两者都映射到更小的物理地址空间。

翻译控制寄存器TCR_EL1定义了检查的最高有效位的确切数量。TCR_EL1包含大小字段T0SZ[5:0]和T1SZ[5:0]。字段中的整数给出了必须全部为0或全部为1的最高有效位的数量。这些字段有指定的最小值和最大值，这些值随粒度大小和起始表级别而变化。因此，您必须始终使用两个空间，并且在所有系统中至少需要两个翻译表。没有操作系统的简单裸机系统仍然需要一个小的上层表，其中仅包含故障条目。

## 12.3 将虚拟地址翻译为物理地址

当处理器为指令获取或数据访问发出64位虚拟地址时，MMU硬件将虚拟地址翻译为相应的物理地址。对于虚拟地址，最高16位[63:47]必须全部为0或1，否则地址会触发故障。

最低有效位用于给出所选部分内的偏移量，因此MMU将块表条目中的物理地址位与原始地址中的最低有效位组合以生成最终地址。

架构还支持标记地址。这是指地址的最高八位被忽略（视为不属于地址的一部分）。这意味着这些位可以用于其他用途，例如记录指针的信息。

在仅涉及一级查找的简单地址翻译中。假设我们使用64KB粒度和42位虚拟地址。MMU按以下方式翻译虚拟地址：

1. 如果VA[63:42]=1，则TTBR1用于第一页表的基地址。当VA[63:42]=0时，TTBR0用于第一页表的基地址。
2. 页表包含8192个64位页表条目，并使用VA[41:29]进行索引。MMU从表中读取相关的第2级页表条目。
3. MMU检查页表条目的有效性以及是否允许请求的内存访问。假设它是有效的，则允许内存访问。
4. 在图12-7中，页表条目引用512MB页（它是一个块描述符）。
5. 从该页表条目中获取位[47:29]并形成物理地址的位[47:29]。
6. 因为我们有一个512MB页，所以VA的位[28:0]用于形成PA[28:0]。
7. 返回完整的PA[47:0]，以及页表条目中的附加信息。

在实践中，这种简单的翻译过程严重限制了您如何精细地划分地址空间。除了仅使用第一级翻译表外，第一级表条目还可以指向第二级页表。

通过这种方式，操作系统可以将虚拟内存的大块进一步划分为更小的页。对于第二级表，第一级描述符包含第二级页表的物理基地址。处理器请求的虚拟地址对应的物理地址在第二级描述符中找到。

图12-8显示了从第1阶段第2级开始的64KB页的翻译示例。

每个第二级表与一个或多个第一级条目相关联。您可以有多个指向同一第二级表的第一级描述符，这意味着您可以将多个虚拟位置别名到同一物理地址。

图12-8描述了涉及两级查找的情况。再次假设64KB粒度和42位虚拟地址空间。

1. 如果VA[63:42]=1，则TTBR1用于第一页表的基地址。当VA[63:42]=0时，TTBR0用于第一页表的基地址。
2. 页表包含8192个64位页表条目，并使用VA[41:29]进行索引。MMU从表中读取相关的第2级页表条目。
3. MMU检查第2级页表条目的有效性以及是否允许请求的内存访问。假设它是有效的，则允许内存访问。
4. 在图12-8中，第2级页表条目引用第3级页表的地址（它是一个表描述符）。
5. 从第2级页表条目中获取位[47:16]并形成第3级页表的基地址。
6. VA的位[28:16]用于索引第3级页表条目。MMU从表中读取相关的第3级页表条目。
7. MMU检查第3级页表条目的有效性以及是否允许请求的内存访问。假设它是有效的，则允许内存访问。
8. 在图12-8中，第3级页表条目引用64KB页（它是一个页描述符）。
9. 从第3级页表条目中获取位[47:16]并用于形成PA[47:16]。
10. 因为我们有一个64KB页，所以VA[15:0]用于形成PA[15:0]。
11. 返回完整的PA[47:0]，以及页表条目中的附加信息。

## 12.3.1 安全和非安全地址

理论上，安全和非安全物理地址空间是相互独立的，并且并行存在。系统可以设计为具有两个完全独立的内存系统。然而，大多数实际系统将安全和非安全视为访问控制的属性。正常（非安全）世界只能访问非安全物理地址空间。安全世界可以访问两个物理地址空间。这再次通过翻译表进行控制。

这也具有缓存一致性的影响。例如，因为安全0x8000和非安全0x8000在技术上是不同的物理地址，它们可以同时在缓存中。

在安全和非安全内存位于不同位置的系统中，不会有问题。更可能的是，它们将位于同一位置。理想情况下，内存系统将阻止安全访问非安全内存和非安全访问安全内存。实际上，大多数系统仅阻止非安全访问安全内存。这意味着您可能会在缓存中两次出现相同的物理内存，安全和非安全。这始终是编程错误。为了避免这种情况，安全世界必须始终使用非安全访问来访问非安全内存。

## 12.3.2 配置和启用MMU

写入控制MMU的系统寄存器是上下文更改事件，它们之间没有顺序要求。在上下文同步事件之前，无法保证看到这些事件的结果（参见第13-6页的屏障）。

```assembly
MSR TTBR0_EL1，X0 // 设置TTBR0
MSR TTBR1_EL1, X1 // 设置TTBR1
MSR TCR_EL1, X2 // 设置TCR
ISB // ISB强制在启用MMU之前看到这些更改。
MRS X0, SCTLR_EL1 // 读取系统控制寄存器配置数据
ORR X0，X0，#1 // 设置[M]位并启用MMU。
MSR SCTLR_EL1，X0 // 写入系统控制寄存器配置数据
ISB // ISB强制下一条指令看到这些更改
```

除了平面映射的要求外，这是为了确保我们知道在写入SCTLR_EL1.M后直接执行哪条指令。如果我们看到写入的结果，则它是使用新翻译机制的VA+4处的指令。如果我们没有看到结果，则它仍然是VA+4处的指令，但VA=PA。ISB在这里没有帮助，因为除非我们平面映射，否则我们无法保证它是下一条执行的指令。

## 12.3.3 内存管理单元禁用时的操作

当第1阶段MMU禁用时，对于非安全EL0和EL1访问，当HCR_EL2.DC位设置为启用数据缓存时，默认内存类型为正常非共享，内部写回读写分配，外部写回读写分配。

## 12.4 ARMv8-A中的翻译表

ARMv8-A架构支持三种不同的翻译表格式：

- ARMv8-A AArch64长描述符格式。
- ARMv7-A长描述符格式，例如ARMv7-A架构的大物理地址扩展（LPAE），在ARM Cortex-A15处理器中找到。
- ARMv7-A短描述符格式。

在AArch32状态下，您可以使用现有的ARMv7-A长和短描述符格式来运行现有的客户操作系统和现有的应用程序代码而无需修改。ARMv7-A短描述符只能用于EL0和EL1第1阶段翻译。因此，它们不能被虚拟机管理程序或安全监视器代码使用。

在AArch64执行状态下始终使用ARMv8-A长描述符格式。这与具有大物理地址扩展的ARMv7-A长描述符格式非常相似。它使用相同的64位长描述符格式，但有一些变化。它引入了一个新的第0级表索引，该索引使用与第1级表相同的描述符格式。它增加了对最多48位输入和输出地址的支持。输入虚拟地址现在来自64位寄存器。然而，由于架构不支持完整的64位寻址，地址的位63:48必须全部相同，即全部为0或全部为1，或者前八位可以用于VA标记。

AArch64支持三种不同的翻译粒度。这些定义了翻译表最低级别的块大小，并控制使用的翻译表的大小。较大的粒度大小减少了所需的页表级别数量，这在使用虚拟机管理程序提供虚拟化的系统中可能成为一个重要的考虑因素。

支持的粒度大小为4KB、16KB和64KB，具体支持哪些大小是IMPLEMENTATION DEFINED。创建页表的代码能够读取系统寄存器ID_AA64MMFR0_EL1，以找出支持的大小。Cortex-A53处理器支持所有三种大小，但某些处理器的早期版本（如Cortex-A57）不支持16K粒度大小。大小可在翻译控制寄存器（TCR_EL1）中为每个翻译表配置。

## 12.4.1 AArch64描述符格式

您可以在所有级别的表中使用描述符格式，从第0级到第3级。第0级描述符只能输出第1级表的地址。第3级描述符不能指向另一个表，只能输出块地址。因此，表的格式在第3级略有不同。

图12-10显示了表描述符类型由条目的位1:0标识，并且可以引用：

- 下一级表的地址，在这种情况下，内存可以进一步细分为更小的块。
- 可变大小内存块的地址。
- 标记为故障或无效的表条目。

**注意**：为了清晰起见，此图未指定位字段的宽度。

## 12.4.2 粒度大小对翻译表的影响

三种不同的粒度大小会影响所需的翻译表的数量和大小。

**注意**：在所有情况下，如果VA输入范围限制为42位，则可以省略第一级表。

根据可能的VA范围的大小，甚至可以更少的级别。例如，使用4KB粒度，如果TTBCR设置为低地址仅跨越1GB，则不需要第0级和第1级，翻译从第2级开始，下降到第3级以获取4KB页。

- **4KB**：当您使用4KB粒度大小时，硬件可以使用4级查找过程。48位地址每级翻译9个地址位，即每个512个条目，最后12位直接从原始地址中选择4KB内的字节。
- **16KB**：当您使用16KB粒度大小时，硬件可以使用4级查找过程。48位地址每级翻译11个地址位，即每个2048个条目，最后14位直接从原始地址中选择4KB内的字节。
- **64KB**：当您使用64KB粒度大小时，硬件可以使用3级查找过程。第1级表仅包含64个条目。

## 12.4.3 缓存配置

MMU使用翻译表和翻译寄存器来控制哪些内存位置是可缓存的。MMU控制缓存策略、内存属性和访问权限，并提供虚拟到物理地址的翻译。

软件配置通过系统寄存器执行（其中一些列在第4章ARMv8寄存器中）。

在某些设计中，外部内存系统可能包含进一步实现特定的外部内存缓存。

## 12.4.4 缓存策略

MMU翻译表还定义了内存系统中每个块的缓存策略。定义为正常的内存区域可能被标记为可缓存或不可缓存。翻译表条目中的位[4:2]引用内存属性间接寄存器（MAIR）中的八种内存属性编码之一。内存属性编码然后指定访问该内存时使用的缓存策略。这些是对处理器的提示，具体实现中是否支持所有缓存策略以及哪些缓存数据被视为一致的是IMPLEMENTATION DEFINED。内存区域可以根据其共享性属性定义。

## 12.5 翻译表配置

除了在TLB中存储单个翻译外，您还可以配置MMU以将翻译表存储在可缓存内存中。这通常比始终从外部内存读取表提供更快的访问速度。TCR_EL1具有控制此功能的附加字段。

附加字段指定TTBR0和TTBR1的翻译表的可缓存性和共享性。相关字段称为SH0/1共享性、IRGN0/1内部可缓存和ORGN0/1外部可缓存。表12-2显示了可缓存性的允许设置。

**表12-2 可缓存性设置**

| IRGN/ORGN位用于TTBR0/TTBR1 | 可缓存属性 |
| --- | --- |
| 00 | 正常内存，内部不可缓存 |
| 01 | 正常内存，内部写回写分配可缓存 |
| 10 | 正常内存，内部写通过可缓存 |
| 11 | 正常内存，内部写回无写分配可缓存 |

与翻译表遍历相关的内存共享性表。对于设备或强序内存区域，该值被忽略。

**表12-3 内存共享性**

| SH0位[13:12] | 共享性 |
| --- | --- |
| 00 | 非共享 |
| 01 | 不可预测 |
| 10 | 外部可共享 |
| 11 | 内部可共享 |

TCR_EL1中指定的属性必须与存储翻译表的虚拟内存区域中指定的属性相同。缓存翻译表是正常的默认行为。

## 12.5.1 虚拟地址标记

翻译控制寄存器TCR_ELn有一个称为顶部字节忽略（TBI）的附加字段，提供标记地址支持。通用寄存器为64位宽，但地址的最高16位必须全部为0xFFFF或0x0000。任何尝试使用不同位值的操作都会触发故障。

当启用标记地址支持时，处理器忽略虚拟地址的最高八位，即[63:56]。它在内部设置位[55]以将地址符号扩展为64位格式。然后，虚拟地址的最高八位可以用于传递数据。这些位在寻址和翻译故障时被忽略。TCR_EL1为EL0和EL1分别启用位。ARM未指定或强制标记地址的特定用例。

一个示例用例可能是支持面向对象的编程语言。除了具有指向对象的指针外，可能还需要保留一个引用计数，以跟踪引用或指针或句柄的数量，例如，以便自动垃圾回收代码可以释放不再引用的对象。此引用计数可以存储为标记地址的一部分，而不是存储在单独的表中，从而加快创建或销毁对象的过程。

## 12.6 EL2和EL3的翻译

ARMv8-A架构的虚拟化扩展引入了第二阶段的翻译。当系统中存在虚拟机管理程序时，可能存在一个或多个客户操作系统。这些操作系统继续使用TTBRn_EL1，如前所述，MMU操作似乎没有变化。

虚拟机管理程序必须在两阶段过程中执行一些额外的翻译步骤，以在不同客户操作系统之间共享物理内存系统。在第一阶段，虚拟地址（VA）被翻译为中间物理地址（IPA）。这通常由操作系统控制。第二阶段，由虚拟机管理程序控制，然后将IPA翻译为最终物理地址（PA）。

虚拟机管理程序和安全监视器还有自己的第1阶段翻译表，用于其自己的代码和数据，这些表直接从VA映射到PA。

**注意**：架构参考手册使用术语“翻译机制”来指代这些不同的表。

图12-15总结了这个两阶段翻译过程。

虚拟机管理程序和安全监视器看到的虚拟内存空间。

第2阶段翻译将中间物理地址转换为物理地址，使用由虚拟机管理程序控制的一组额外表。必须通过写入虚拟机管理程序配置寄存器HCR_EL2显式启用此过程。此过程仅适用于非安全EL1/0访问。

此第2阶段翻译表的基地址在虚拟化翻译表基寄存器VTTBR0_EL2中指定。它指定内存底部的单个连续地址空间。支持的地址空间大小在虚拟化翻译控制寄存器VTCR_EL2的TSZ[5:0]字段中指定。

该寄存器的TG字段指定粒度大小，而SL0字段控制表查找的第一级。任何访问定义地址范围之外的操作都会导致翻译故障。

虚拟机管理程序EL2和安全监视器EL3有自己的第1级表，这些表直接从虚拟地址映射到物理地址空间。表基地址分别在TTBR0_EL2和TTBR0_EL3中指定，启用内存底部的可变大小的单个连续地址空间。TG字段指定粒度大小，SL0字段控制表查找的第一级。任何访问定义地址范围之外的操作都会导致翻译故障。

安全监视器EL3有自己的专用翻译表。表基地址在TTBR0_EL3中指定，并通过TCR_EL3配置。翻译表能够访问安全和非安全物理地址。TTBR0_EL3仅在安全监视器EL3模式下使用，而不是由受信任的内核本身使用。当转换到安全世界完成后，受信任的内核使用EL1翻译，即由TTBR0_EL1和TTBR1_EL1指向的翻译表。由于这些寄存器在AArch64中未分块，安全监视器代码必须为安全世界配置新表，并保存和恢复TTBR0_EL1和TTBR1_EL1的副本。

EL1翻译机制在安全状态下的行为与其在非安全状态下的正常操作不同。第二阶段的翻译被禁用，EL1翻译机制现在能够指向安全或非安全物理地址。安全世界中没有虚拟化，因此IPA始终与最终PA相同。

TLB中的条目被标记为安全或非安全，因此在您从安全世界转换到正常世界时，永远不需要TLB维护。

## 12.7 访问权限

在翻译表条目中，访问权限位（AP）控制内存区域的访问权限。这些权限位定义了内存区域是否可读、可写，或者两者兼有，并且可以分别设置为非特权访问（EL0）和特权访问（EL1、EL2和EL3）。表12-4总结了这些访问权限的设置。

**表12-4 访问权限**

| AP 非特权（EL0） | 特权（EL1/2/3） |
| --- | --- |
| 00 无访问 | 读写 |
| 01 读写 | 读写 |
| 10 无访问 | 只读 |
| 11 只读 | 只读 |

操作系统内核在EL1执行级别运行。它定义了翻译表映射，这些映射由内核本身和在EL0运行的应用程序使用。非特权和特权访问权限之间的区别是必需的，因为内核为其自己的代码和应用程序指定了不同的权限。在EL2运行的虚拟机管理程序和EL3的安全监视器只有自己的翻译方案，因此不需要在权限中进行特权和用户访问的区分。

## 12.8 内存属性和缓存策略

内存属性和缓存策略通过翻译表条目中的内存属性字段进行控制。这些字段定义了内存区域的类型（例如正常内存、设备内存等）以及缓存行为（例如写回、写通过等）。内存属性字段引用内存属性间接寄存器（MAIR）中的编码，MAIR中定义了八种不同的内存属性编码。

### 12.8.1 内存属性间接寄存器（MAIR）

MAIR寄存器允许软件定义八种不同的内存属性编码。每个编码对应一个特定的内存类型和缓存策略。翻译表条目中的内存属性字段引用这些编码，从而为每个内存区域指定适当的内存属性和缓存策略。

**表12-5 MAIR编码示例**

| 编码 | 内存类型 | 缓存策略 |
| --- | --- | --- |
| 0 | 正常内存 | 不可缓存 |
| 1 | 正常内存 | 写回写分配 |
| 2 | 正常内存 | 写通过 |
| 3 | 设备内存 | 不可缓存 |
| 4 | 强序内存 | 不可缓存 |

### 12.8.2 缓存策略

缓存策略定义了内存区域的缓存行为。常见的缓存策略包括：

- **不可缓存**：内存区域不会被缓存，所有访问都直接访问外部内存。
- **写回写分配**：内存区域被缓存，写操作首先写入缓存，稍后再写回外部内存。
- **写通过**：内存区域被缓存，写操作同时写入缓存和外部内存。

缓存策略的选择取决于内存区域的使用场景。例如，对于频繁访问的数据，通常使用写回写分配策略以提高性能；而对于设备内存，通常使用不可缓存策略以确保访问的实时性。

## 12.9 虚拟化扩展中的内存管理

ARMv8-A架构的虚拟化扩展引入了第二阶段的翻译，允许虚拟机管理程序在客户操作系统和物理内存之间进行额外的地址翻译。这种两阶段的翻译过程使得虚拟机管理程序能够有效地管理多个客户操作系统的内存资源。

### 12.9.1 两阶段翻译

在虚拟化环境中，内存管理分为两个阶段：

1. **第一阶段翻译**：由客户操作系统控制，将虚拟地址（VA）翻译为中间物理地址（IPA）。
2. **第二阶段翻译**：由虚拟机管理程序控制，将中间物理地址（IPA）翻译为最终物理地址（PA）。

虚拟机管理程序通过配置虚拟化翻译表基寄存器（VTTBR0_EL2）和虚拟化翻译控制寄存器（VTCR_EL2）来控制第二阶段的翻译过程。

### 12.9.2 虚拟机管理程序的内存管理

虚拟机管理程序在EL2执行级别运行，负责管理多个客户操作系统的内存资源。虚拟机管理程序通过配置第二阶段的翻译表，确保每个客户操作系统的内存访问不会干扰其他客户操作系统或虚拟机管理程序本身的内存。

虚拟机管理程序还可以通过配置内存属性和访问权限，限制客户操作系统对某些内存区域的访问。例如，虚拟机管理程序可以禁止客户操作系统访问虚拟机管理程序的内存区域，以确保系统的安全性。

## 12.10 安全扩展中的内存管理

ARMv8-A架构的安全扩展引入了安全状态和非安全状态的概念。在安全状态下，内存管理单元（MMU）可以访问安全和非安全物理地址空间，而在非安全状态下，MMU只能访问非安全物理地址空间。

### 12.10.1 安全状态下的内存管理

在安全状态下，MMU可以访问安全和非安全物理地址空间。安全监视器在EL3执行级别运行，负责管理安全状态下的内存资源。安全监视器通过配置安全翻译表，确保安全状态下的内存访问不会干扰非安全状态下的内存访问。

安全监视器还可以通过配置内存属性和访问权限，限制非安全状态下的内存访问。例如，安全监视器可以禁止非安全状态下的访问安全内存区域，以确保系统的安全性。

### 12.10.2 非安全状态下的内存管理

在非安全状态下，MMU只能访问非安全物理地址空间。非安全状态下的内存管理由客户操作系统控制，客户操作系统通过配置翻译表，管理非安全状态下的内存资源。

## 12.11 总结

ARMv8-A架构的内存管理单元（MMU）提供了强大的虚拟地址到物理地址的翻译功能，支持多种粒度大小、内存属性和缓存策略。通过配置翻译表和控制寄存器，操作系统和虚拟机管理程序可以有效地管理内存资源，确保系统的性能和安全性。

虚拟化扩展和安全扩展进一步增强了ARMv8-A架构的内存管理能力，使得虚拟机管理程序和安全监视器能够有效地管理多个客户操作系统的内存资源，并确保系统的安全性。

理解ARMv8-A架构的内存管理机制对于开发高效、安全的操作系统和应用程序至关重要。通过合理配置翻译表和控制寄存器，可以最大限度地发挥ARMv8-A架构的性能优势，并确保系统的稳定性和安全性。