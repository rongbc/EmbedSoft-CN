### 14.8. 处理固件
作为一名驱动程序开发者，你可能会遇到这样的设备：在正常运行之前，必须先将固件下载到其中。如今，硬件市场许多领域的竞争十分激烈，以至于为设备控制固件配备少量EEPROM的成本，都超出了制造商的预算。因此，固件通常随硬件一起通过光盘分发，而操作系统则负责将固件传输到设备中。

你或许会想通过如下声明来解决固件问题：
```c
static char my_firmware[  ] = { 0x34, 0x78, 0xa4, ... };
```
然而，这种方法几乎肯定是错误的。将固件代码硬编码到驱动程序中会使驱动程序代码膨胀，增加固件升级的难度，并且极有可能引发许可问题。供应商几乎不会在GPL许可下发布固件镜像，因此将其与遵循GPL许可的代码混合通常是不可取的。出于这个原因，包含内置固件的驱动程序不太可能被纳入主线内核，也不会被Linux发行版采用。

#### 14.8.1. 内核固件接口
正确的解决方法是在需要时从用户空间获取固件。不过，请不要尝试在内核空间直接打开包含固件的文件，这是一个容易出错的操作，并且会将策略（以文件名的形式）放入内核。正确的做法是使用专门为此目的创建的固件接口：
```c
#include <linux/firmware.h>
int request_firmware(const struct firmware **fw, char *name,
                     struct device *device);
```
调用`request_firmware`会请求用户空间定位并向内核提供固件镜像；我们稍后会详细了解其工作原理。`name`参数用于指定所需的固件，通常使用供应商提供的固件文件名，例如`my_firmware.bin`。如果固件成功加载，返回值为0（否则返回常规错误代码），`fw`参数会指向以下结构体之一：
```c
struct firmware {
        size_t size;
        u8 *data;
};
```
该结构体包含实际的固件，现在可以将其下载到设备中。请注意，这个固件是来自用户空间未经校验的数据，在将其发送到硬件之前，你应该进行所有能想到的测试，以确保它是正确的固件镜像。设备固件通常包含标识字符串、校验和等信息，在信任这些数据之前，务必检查所有这些内容。

将固件发送到设备后，你应该使用以下函数释放内核中的结构体：
```c
void release_firmware(struct firmware *fw);
```
由于`request_firmware`需要用户空间的协助，因此在返回之前它一定会进入睡眠状态。如果你的驱动程序在请求固件时不能进入睡眠状态，可以使用异步方式：
```c
int request_firmware_nowait(struct module *module, 
                            char *name, struct device *device, void *context,
                            void (*cont)(const struct firmware *fw, void *context));
```
这里额外的参数有`module`（几乎总是`THIS_MODULE`）、`context`（固件子系统不会使用的私有数据指针）和`cont`。如果一切顺利，`request_firmware_nowait`会启动固件加载过程并返回0。在未来某个时刻，`cont`会被调用，并传入加载结果。如果由于某种原因固件加载失败，`fw`将为`NULL`。

#### 14.8.2. 工作原理
固件子系统与sysfs和热插拔机制协同工作。当调用`request_firmware`时，会在`/sys/class/firmware`下使用你的设备名称创建一个新目录。该目录包含三个属性：
- **loading**：负责加载固件的用户空间进程应将此属性设置为1。加载过程完成后，应将其设置为0。向`loading`写入-1会中止固件加载过程。
- **data**：`data`是一个二进制属性，用于接收固件数据本身。在设置`loading`属性后，用户空间进程应将固件写入此属性。
- **device**：该属性是一个符号链接，指向`/sys/devices`下的相关条目。

创建sysfs条目后，内核会为你的设备生成一个热插拔事件。传递给热插拔处理程序的环境变量中包含一个`FIRMWARE`变量，其值被设置为提供给`request_firmware`的名称。处理程序应定位固件文件，并使用提供的属性将其复制到内核中。如果找不到该文件，处理程序应将`loading`属性设置为-1。

如果在10秒内固件请求未得到处理，内核将放弃并向驱动程序返回失败状态。这个超时时间可以通过sysfs属性`/sys/class/firmware/timeout`进行更改。

使用`request_firmware`接口可以让你将设备固件与驱动程序一起分发。当与热插拔机制正确集成后，固件加载子系统可以让设备实现 “开箱即用”。显然，这是处理该问题的最佳方式。

不过，请允许我们再提出一个警告：未经制造商许可，不应分发设备固件。许多制造商在收到礼貌的请求时，会同意在合理的条款下授权其固件；但也有一些制造商可能不太配合。无论哪种情况，未经许可复制和分发他们的固件都违反了版权法，可能会带来麻烦。 