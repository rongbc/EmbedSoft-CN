### 14.7. 热插拔
热插拔可以从两种不同的角度来看待。内核将热插拔视为硬件、内核和内核驱动程序之间的交互。用户则将热插拔看作是内核通过名为`/sbin/hotplug`的程序与用户空间进行的交互。当内核想要通知用户空间内核中发生了某种类型的热插拔事件时，就会调用这个程序。

#### 14.7.1. 动态设备
“热插拔” 这个术语最常用的含义是指现在大多数计算机系统都能够在系统运行时处理设备的出现或消失。这与几年前的计算机系统大不相同，在过去，程序员们只需要在系统启动时扫描所有设备，并且在整个机器断电之前，他们从不用担心设备会消失。如今，随着USB、CardBus、PCMCIA、IEEE1394和PCI热插拔控制器的出现，无论系统中添加或移除何种硬件，Linux内核都需要能够可靠地运行。这给设备驱动程序开发者增加了额外的负担，因为他们现在必须随时处理设备突然被移除而毫无预警的情况。

每种不同的总线类型处理设备丢失的方式各不相同。例如，当从系统中移除PCI、CardBus或PCMCIA设备时，通常要过一段时间驱动程序才会通过其移除函数收到这一操作的通知。在此之前，从PCI总线的所有读取操作返回的都是全1值。这意味着驱动程序需要始终检查从PCI总线读取的数据值，并能够正确处理`0xff`这个值。

在`drivers/usb/host/ehci-hcd.c`驱动程序（这是一个用于USB 2.0（高速）控制器卡的PCI驱动程序）中可以看到这样的示例。在其主要的握手循环中，有以下代码用于检测控制器卡是否已从系统中移除：
```c
result = readl(ptr);
if (result == ~(u32)0)    /* 卡已移除 */
    return -ENODEV;
```
对于USB驱动程序，当与USB驱动程序绑定的设备从系统中移除时，任何提交给该设备但尚未完成的USB请求块（urb）都会开始返回`-ENODEV`错误。如果出现这种情况，驱动程序需要识别这个错误并正确清理任何未完成的I/O操作。

可热插拔的设备不仅限于鼠标、键盘和网卡等传统设备。现在有许多系统支持整个CPU和内存模块的移除和添加。幸运的是，Linux内核能够正确处理这些核心 “系统” 设备的添加和移除，因此单个设备驱动程序无需关注这些事情。

#### 14.7.2. /sbin/hotplug工具
正如本章前面所提到的，每当系统中添加或移除设备时，就会生成一个 “热插拔事件”。这意味着内核会调用用户空间程序`/sbin/hotplug`。这个程序通常是一个非常小的bash脚本，它只是将执行权传递给位于`/etc/hotplug.d/`目录树中的其他程序列表。对于大多数Linux发行版，这个脚本内容如下：
```bash
DIR="/etc/hotplug.d"
for I in "${DIR}/$1/"*.hotplug "${DIR}/"default/*.hotplug ; do
    if [ -f $I ]; then
        test -x $I && $I $1 ;
    fi
done
exit 1
```
换句话说，这个脚本会搜索所有可能对该事件感兴趣的、带有`.hotplug`后缀的程序，并调用它们，同时将内核设置的多个不同环境变量传递给这些程序。关于`/sbin/hotplug`脚本的工作原理的更多详细信息，可以在程序中的注释以及`hotplug(8)`手册页中找到。

如前所述，每当创建或销毁一个`kobject`时，就会调用`/sbin/hotplug`。调用`hotplug`程序时会传递一个命令行参数，该参数为事件提供一个名称。涉及的内核核心和特定子系统还会设置一系列环境变量（如下所述），这些变量包含刚刚发生的事件的相关信息。热插拔程序使用这些变量来确定内核中刚刚发生了什么，以及是否应该执行任何特定操作。

传递给`/sbin/hotplug`的命令行参数是与这个热插拔事件相关联的名称，该名称由分配给`kobject`的`kset`确定。这个名称可以通过调用`kset`的`hotplug_ops`结构（本章前面介绍过）中的`name`函数来设置；如果该函数不存在或从未被调用，那么名称就是`kset`本身的名称。

为`/sbin/hotplug`程序始终设置的默认环境变量有：
- **ACTION**：字符串`add`或`remove`，取决于相关对象是刚刚创建还是销毁。
- **DEVPATH**：sysfs文件系统中的一个目录路径，指向正在被创建或销毁的`kobject`。需要注意的是，sysfs文件系统的挂载点不会添加到这个路径中，因此这需要由用户空间程序来确定。
- **SEQNUM**：这个热插拔事件的序列号。序列号是一个64位的数字，每次生成热插拔事件时都会递增。这使得用户空间能够按照内核生成热插拔事件的顺序对它们进行排序，因为用户空间程序有可能会乱序运行。
- **SUBSYSTEM**：与上述作为命令行参数传递的字符串相同。

当与总线相关的设备添加到系统或从系统中移除时，许多不同的总线子系统都会向`/sbin/hotplug`调用添加它们自己的环境变量。它们在分配给总线的`struct kset_hotplug_ops`中指定的热插拔回调函数中进行此操作（如14.3.1节所述）。这使得用户空间能够自动加载控制总线上新发现的设备可能需要的任何必要模块。以下是不同总线类型以及它们向`/sbin/hotplug`调用添加的环境变量列表。

#### 14.7.2.1 IEEE1394（火线）
IEEE1394总线上的任何设备（也称为火线设备），其`/sbin/hotplug`参数名称和`SUBSYSTEM`环境变量都设置为值`ieee1394`。IEEE1394子系统还总是添加以下四个环境变量：
- **VENDOR_ID**：IEEE1394设备的24位供应商ID
- **MODEL_ID**：IEEE1394设备的24位型号ID
- **GUID**：设备的64位全局唯一标识符（GUID）
- **SPECIFIER_ID**：指定此设备协议规范所有者的24位值
- **VERSION**：指定此设备协议规范版本的值

#### 14.7.2.2 网络
所有网络设备在内核中注册或注销时都会创建一个热插拔事件。`/sbin/hotplug`调用的参数名称和`SUBSYSTEM`环境变量都设置为值`net`，并且只添加以下环境变量：
- **INTERFACE**：已在内核中注册或注销的接口名称。例如`lo`和`eth0`。

#### 14.7.2.3 PCI
PCI总线上的任何设备，其参数名称和`SUBSYSTEM`环境变量都设置为值`pci`。PCI子系统还总是添加以下四个环境变量：
- **PCI_CLASS**：设备的PCI类编号，以十六进制表示。
- **PCI_ID**：设备的PCI供应商和设备ID，以十六进制表示，格式为`vendor:device`。
- **PCI_SUBSYS_ID**：PCI子系统供应商和子系统设备ID，格式为`subsys_vendor:subsys_device`。
- **PCI_SLOT_NAME**：内核分配给设备的PCI插槽 “名称”。格式为`domain:bus:slot:function`。例如`0000:00:0d.0`。

#### 14.7.2.4 输入设备
对于所有输入设备（鼠标、键盘、游戏杆等），当设备在内核中添加或移除时会生成热插拔事件。`/sbin/hotplug`参数和`SUBSYSTEM`环境变量都设置为值`input`。输入子系统还总是添加以下环境变量：
- **PRODUCT**：一个多值字符串，以十六进制列出值且无前导零。格式为`bustype:vendor:product:version`。

如果设备支持，可能还会存在以下环境变量：
- **NAME**：设备给出的输入设备名称。
- **PHYS**：输入子系统分配给此设备的物理地址。根据设备插入的总线位置，这个地址应该是稳定的。
- **EV**、**KEY**、**REL**、**ABS**、**MSC**、**LED**、**SND**、**FF**：这些都来自输入设备描述符，如果特定输入设备支持，会设置为相应的值。

#### 14.7.2.5 USB
USB总线上的任何设备，其参数名称和`SUBSYSTEM`环境变量都设置为值`usb`。USB子系统还总是添加以下环境变量：
- **PRODUCT**：格式为`idVendor/idProduct/bcdDevice`的字符串，指定那些USB设备特定的字段
- **TYPE**：格式为`bDeviceClass/bDeviceSubClass/bDeviceProtocol`的字符串，指定那些USB设备特定的字段

如果`bDeviceClass`字段设置为0，还会设置以下环境变量：
- **INTERFACE**：格式为`bInterfaceClass/bInterfaceSubClass/bInterfaceProtocol`的字符串，指定那些USB设备特定的字段。

如果选择了内核构建选项`CONFIG_USB_DEVICEFS`（该选项用于选择在内核中构建`usbfs`文件系统），还会设置以下环境变量：
- **DEVICE**：一个字符串，显示设备在`usbfs`文件系统中的位置。这个字符串的格式为`/proc/bus/usb/USB_BUS_NUMBER/USB_DEVICE_NUMBER`，其中`USB_BUS_NUMBER`是设备所在USB总线的三位数字编号，`USB_DEVICE_NUMBER`是内核分配给该USB设备的三位数字编号。

#### 14.7.2.6 SCSI
所有SCSI设备在内核中创建或移除时都会创建一个热插拔事件。对于系统中添加或移除的每个SCSI设备，`/sbin/hotplug`调用的参数名称和`SUBSYSTEM`环境变量都设置为值`scsi`。SCSI系统不会添加其他环境变量，但在此提及是因为有一个特定于SCSI的用户空间脚本，它可以确定应为指定的SCSI设备加载哪些SCSI驱动程序（磁盘、磁带、通用等）。

#### 14.7.2.7 笔记本电脑扩展坞
如果一个支持即插即用的笔记本电脑扩展坞添加到运行中的Linux系统（通过将笔记本电脑插入扩展坞）或从系统中移除（通过将笔记本电脑从扩展坞拔出），就会创建一个热插拔事件。`/sbin/hotplug`调用的参数名称和`SUBSYSTEM`环境变量都设置为值`dock`。不会设置其他环境变量。

#### 14.7.2.8 S/390和zSeries
在S/390架构中，通道总线架构支持广泛的硬件设备，当这些设备添加到Linux虚拟系统或从系统中移除时，都会生成`/sbin/hotplug`事件。这些设备的`/sbin/hotplug`参数名称和`SUBSYSTEM`环境变量都设置为值`dasd`。不会设置其他环境变量。

#### 14.7.3. 使用/sbin/hotplug
既然Linux内核会为内核中添加和移除的每个设备调用`/sbin/hotplug`，那么在用户空间就创建了许多非常有用的工具来利用这一点。其中两个最受欢迎的工具是Linux热插拔脚本和`udev`。

#### 14.7.3.1 Linux热插拔脚本
Linux热插拔脚本是最早使用`/sbin/hotplug`调用的程序。这些脚本会查看内核设置的不同环境变量，这些变量用于描述刚刚发现的设备，然后尝试找到与该设备匹配的内核模块。

如前所述，当驱动程序使用`MODULE_DEVICE_TABLE`宏时，`depmod`程序会获取该信息并创建位于`/lib/module/KERNEL_VERSION/modules.*map`中的文件。其中`*`会根据驱动程序支持的总线类型而有所不同。目前，为支持PCI、USB、IEEE1394、INPUT、ISAPNP和CCW子系统设备的驱动程序生成模块映射文件。

热插拔脚本使用这些模块映射文本文件来确定尝试加载哪个模块以支持内核最近发现的设备。它们会加载所有匹配的模块，而不会在找到第一个匹配项时就停止，以便让内核确定哪个模块最适合。当设备被移除时，这些脚本不会卸载任何模块。如果它们尝试这样做，可能会意外关闭那些也由被移除设备的同一驱动程序控制的其他设备。

需要注意的是，现在`modprobe`程序可以直接从模块中读取`MODULE_DEVICE_TABLE`信息，而无需模块映射文件，因此热插拔脚本可能会简化为围绕`modprobe`程序的一个小包装。

#### 14.7.3.2 udev
在内核中创建统一驱动模型的主要原因之一是为了让用户空间能够动态管理`/dev`树。以前在用户空间通过`devfs`来实现这一点，但由于缺乏积极的维护者以及一些无法修复的核心错误，`devfs`代码库逐渐不再适用。许多内核开发者意识到，如果将所有设备信息导出到用户空间，用户空间就可以对`/dev`树进行所有必要的管理。

`devfs`在设计上存在一些非常基本的缺陷。它要求每个设备驱动程序都进行修改以支持它，并且要求设备驱动程序指定其在`/dev`树中的名称和位置。它也不能正确处理动态的主设备号和次设备号，并且不允许用户空间以简单的方式覆盖设备命名，这使得设备命名策略只能存在于内核中，而不是用户空间。Linux内核开发者非常不喜欢在内核中设置策略，并且由于`devfs`的命名策略不符合Linux标准库规范，这让他们很困扰。

随着Linux内核开始安装在大型服务器上，许多用户遇到了如何管理大量设备的问题。拥有超过10,000个独特设备的磁盘驱动器阵列带来了一个非常棘手的任务，即确保特定磁盘始终被赋予完全相同的名称，无论它在磁盘阵列中的位置如何，或者何时被内核发现。同样的问题也困扰着桌面用户，当他们试图将两台USB打印机连接到系统时，他们会意识到，如果系统重启，他们无法确保名为`/dev/lpt0`的打印机不会改变，并且不会被分配给另一台打印机。

因此，`udev`应运而生。它依赖于通过sysfs将所有设备信息导出到用户空间，并依赖于`/sbin/hotplug`通知它设备的添加或移除。诸如给设备取什么名字之类的策略决策可以在用户空间而不是内核中指定。这确保了命名策略从内核中移除，并为每个设备的名称提供了很大的灵活性。

有关如何使用和配置`udev`的更多信息，请参阅发行版中`udev`软件包附带的文档。

为了让`udev`与设备驱动程序正常工作，设备驱动程序需要做的就是确保通过sysfs将分配给其控制的设备的任何主设备号和次设备号导出到用户空间。对于任何使用子系统来分配主设备号和次设备号的驱动程序，子系统已经完成了这项工作，驱动程序无需再做任何事情。执行此操作的子系统示例包括`tty`、`misc`、`usb`、`input`、`scsi`、`block`、`i2c`、`network`和`frame buffer`子系统。如果驱动程序通过调用`cdev_init`函数或旧的`register_chrdev`函数自行获取主设备号和次设备号，则需要对驱动程序进行修改，以便`udev`能够与之正常工作。

`udev`会在sysfs的`/class/`树中查找一个名为`dev`的文件，以便在内核通过`/sbin/hotplug`接口调用它时，确定分配给特定设备的主设备号和次设备号。设备驱动程序只需要为其控制的每个设备创建该文件。`class_simple`接口通常是实现此目的的最简单方法。

如14.5.1节所述，使用`class_simple`接口的第一步是通过调用`class_simple_create`函数创建一个`struct class_simple`：
```c
static struct class_simple *foo_class;
...
foo_class = class_simple_create(THIS_MODULE, "foo");
if (IS_ERR(foo_class)) {
    printk(KERN_ERR "Error creating foo class.\n");
    goto error;
}
```
这段代码会在sysfs的`/sys/class/foo`目录下创建一个目录。

每当驱动程序发现一个新设备，并按照第3章所述为其分配一个次设备号时，驱动程序应该调用`class_simple_device_add`函数：
```c
class_simple_device_add(foo_class, MKDEV(FOO_MAJOR, minor), NULL, "foo%d", minor);
```
这段代码会在`/sys/class/foo`目录下创建一个名为`fooN`的子目录，其中`N`是该设备的次设备号。在这个目录中会创建一个文件`dev`，这正是`udev`为设备创建设备节点所需要的文件。

当驱动程序与设备解除绑定并释放其所关联的次设备号时，需要调用`class_simple_device_remove`来移除该设备的sysfs条目：
```c
class_simple_device_remove(MKDEV(FOO_MAJOR, minor));
```
之后，当整个驱动程序关闭时，需要调用`class_simple_destroy`来移除最初通过调用`class_simple_create`创建的类：
```c
class_simple_destroy(foo_class);
```
通过调用`class_simple_device_add`创建的`dev`文件由主设备号和次设备号组成，中间用冒号（`:`）分隔。如果驱动程序不想使用`class_simple`接口，因为你想在类目录中为子系统提供其他文件，那么可以使用`print_dev_t`函数为特定设备正确格式化主设备号和次设备号。 